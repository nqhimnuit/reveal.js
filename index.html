<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Java EE Architecture</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">
	<link rel="stylesheet" href="lib/css/monokai.css">
</head>

<body>
<div class="reveal">
	<div class="slides">
		<section>
			<h1>Agenda</h1>
			<ol>
				<li>Java EE 7 standard services</li>
				<li>Contexts and Dependency Injection</li>
				<li>Enterprise JavaBeans</li>
				<li>JavaBean Validation</li>
				<li>Web Services with JAX-RS</li>
				<li>Packaging</li>
			</ol>
		</section>
		<section>
			<section>
				<h1>Java EE 7 standard services</h1>
			</section>
			<section>
				<h2>Java EE 7 standard services</h2>
				<table style="font-size: 22pt">
					<tr>
						<td>1. EJB</td>
						<td>8. JAX-RS</td>
						<td>15. JavaMail</td>
					</tr>
					<tr>
						<td>2. Servlet</td>
						<td>9. Managed Beans</td>
						<td>16. JACC</td>
					</tr>
					<tr>
						<td>3. JSF</td>
						<td>10. CDI</td>
						<td>17. JASPIC</td>
					</tr>
					<tr>
						<td>4. JSP</td>
						<td>11. Dependency Injection</td>
						<td>18. WebSocket</td>
					</tr>
					<tr>
						<td>5. JSTL</td>
						<td>12. Bean Validation</td>
						<td>19. JSON-P</td>
					</tr>
					<tr>
						<td>6. JPA</td>
						<td>13. Java Message Service</td>
						<td>20. Concurrency Utilities</td>
					</tr>
					<tr>
						<td>7. JTA</td>
						<td>14. Java EE connector Architecture</td>
						<td>21. Batch</td>
					</tr>
				</table>
			</section>
			<!--			<section>-->
			<!--				<h2>Java EE 7 standard services</h2>-->
			<!--				<ol style="font-size: 9pt">-->
			<!--					<li>EJB</li>-->
			<!--					To implement modules of Business logic.-->
			<!--					<li>Servlet</li>-->
			<!--					Provide URL mapping and request handling capabilities in Java web app.-->
			<!--					<li>JSF</li>-->
			<!--					User interface framework for web app.-->
			<!--					<li>JSP</li>-->
			<!--					Lets you put snippets of servlet code.-->
			<!--					<li>JSTL</li>-->
			<!--					JavaServer Pages Standard Tag Library encapsulates core functionalities for-->
			<!--					JSP apps.-->
			<!--					<li>JPA</li>-->
			<!--					Java Persistence API is for management of persistence and orm.-->
			<!--					<li>JTA</li>-->
			<!--					Java Transaction API provides a standard interface for demarcating-->
			<!--					transactions.-->
			<!--					<li>JAX-RS</li>-->
			<!--					Java API for RESTful Web Services defines API to build web services-->
			<!--					according to the REST architectural.-->
			<!--					<li>Managed Beans</li>-->
			<!--					Support a small set of basic services, such as resource injection, lifecycle-->
			<!--					callbacks, and interceptors-->
			<!--					<li>CDI</li>-->
			<!--					Allows developers to integrate different kinds of components in a loosely-->
			<!--					coupled but typesafe way.-->
			<!--					<li>Dependency Injection</li>-->
			<!--					Defines a standard set of annotations for use on injectable classes.-->
			<!--					<li>Bean Validation</li>-->
			<!--					Defines metadata model and API for validating data in JavaBeans components.-->
			<!--					<li>JavaBeans Activation Framework (JAF)</li>-->
			<!--					Framework for handling data in different MIME types.-->
			<!--					<li>Java EE Connector Architecture</li>-->
			<!--					To create resource adapters that support access to enterprise information-->
			<!--					systems that can be plugged in to any Java EE product.-->
			<!--					<li>JavaMail</li>-->
			<!--					Allows a component to send e-mail-->
			<!--					<li>JACC</li>-->
			<!--					Defines a contract between a Java EE application server and an authorization-->
			<!--					policy provider-->
			<!--					<li>JASPIC</li>-->
			<!--					Defines a service provider interface by which authentication providers that-->
			<!--					implement message authentication mechanisms-->
			<!--					may be integrated in client or server message-processing containers or-->
			<!--					runtimes.-->
			<!--					<li>WebSocket</li>-->
			<!--					Enables Java EE applications to create endpoints using annotations that-->
			<!--					specify the configuration parameters-->
			<!--					of the endpoint and designate its lifecycle callback methods-->
			<!--					<li>JSON-P</li>-->
			<!--					Enables Java EE applications to parse, transform, and query JSON data using-->
			<!--					the object model or the streaming model-->
			<!--					<li>Concurrency Utilities</li>-->
			<!--					Standard API for providing asynchronous-->
			<!--					<li>Batch</li>-->
			<!--					Provide programming model for batch applications and a runtime for-->
			<!--					scheduling and executing jobs.-->
			<!--				</ol>-->
			<!--			</section>-->
		</section>
		<section>
			<section>
				<h1>Contexts and Dependency Injection</h1>
			</section>
			<section>
				<h2>Contexts and Dependency Injection</h2>
				<pre>
					<code data-trim data-noescape style="font-size: 10pt">
						public class EntityServiceFactory {
							private SetupService setupService;
							private SetupStateService setupStateService;
							private ResourceServerService resourceServerService;
							private ResourceServerStateService resourceServerStateService;
							private ClientService clientService;
							private ClientStateService clientStateService;
							private RefreshTokenService refreshTokenService;
							private PersistedConsentService persistedConsentService;

						// ...
						}
					</code>
				</pre>
				<p style="font-size: 28pt">How can we use these services and their dependencies?</p>
			</section>
			<section>
				<h2>Contexts and Dependency Injection (CDI)</h2>
				<ul>
					<li><b style="color: #a6e22e">Contexts:</b> bind the lifecycle and interactions
						of stateful components to well-defined but extensible lifecycle contexts.
					</li>
					<li><b style="color: #a6e22e">Dependency injection:</b> inject components into
						an app in a typesafe way and to choose at deployment time which
						implementation of a particular interface to inject.
					</li>
				</ul>
			</section>
			<section>
				<h2>Contexts and Dependency Injection (CDI)</h2>
				<p style="text-align: left">A major theme of CDI is loose coupling.
					CDI makes it possible to inject more kinds of objects:</p>
				<ul style="font-size: 22pt">
					<li>(Almost) any Java class</li>
					<li>Session beans</li>
					<li>Java EE resources</li>
					<li>Persistence contexts</li>
					<li>Producer fields</li>
					<li>Object returned by producer methods</li>
					<li>Web service references</li>
					<li>Remote enterprise bean references</li>
				</ul>
			</section>
			<section>
				<h2>Contexts and Dependency Injection (CDI)</h2>
				<p style="text-align: left">CDI provides services:</p>
				<ul style="font-size: 22pt">
					<li>integration with Expression Language (EL)</li>
					<li>decorate injected components</li>
					<li>associate interceptors with components using typesafe interceptor bindings
					</li>
					<li>event-notification model</li>
					<li>web conversation scope</li>
					<li>complete Service Provider Interface allowing third-party frameworks to
						integrate cleanly in Java EE 7 environment.
					</li>
				</ul>
			</section>
			<section style="font-size: x-large">
				<h2>Contexts and Dependency Injection</h2>
				<p style="text-align: left">To maintain state over the duration of user's
					interaction with the application, we can provide scope to the bean.</p>
				<table>
					<tr>
						<th>Scope</th>
						<th>Annotation</th>
						<th>Duration</th>
					</tr>
					<tr>
						<td>Request</td>
						<td>@RequestScoped</td>
						<td>User's interaction with a web app in a single HTTP request</td>
					</tr>
					<tr>
						<td>Session</td>
						<td>@SessionScoped</td>
						<td>User's interaction with a web app in multiple HTTP requests</td>
					</tr>
					<tr>
						<td>Application</td>
						<td>@ApplicationScoped</td>
						<td>Shared state across all users' interactions with a web app</td>
					</tr>
					<tr>
						<td>Dependent</td>
						<td>@Dependent</td>
						<td>Default scope if none is specified. An object exists to serve exactly 1
							client and has the same lifecycle as that client.
						</td>
					</tr>
					<tr>
						<td>Conversation</td>
						<td>@ConversationScoped</td>
						<td>User's interaction with a servlet, including JavaServer Faces
							applications
						</td>
					</tr>
				</table>
			</section>
		</section>
		<section>
			<section>
				<h1>Enterprise Bean</h1>
			</section>
			<section>
				<h2>Enterprise Bean</h2>
				<ul>
					<li>Enterprise Beans are Java EE components that implement EJB technology, run
						in EJB container.
					</li>
					<li>Encapsulates the business logic of an application.</li>
					<li>Helps simplify the development of large, distributed applications.</li>
				</ul>
			</section>
			<section style="width: 800pt;right: -86.667px;left: -86.667px;">
				<h2>Enterprise Bean</h2>
				<p style="text-align: left">There are 2 types:</p>
				<ul>
					<li><b style="color: #a6e22e">Session Bean:</b> performs task for a client, may
						implement a web service. Has 3 types: stateful, stateless and singleton.
					</li>
					<li><b style="color: #a6e22e">Message-driven Bean:</b> acts as a listener for a
						particular messaging type,
						such as the Java Message Service API. Allows Java EE app to process messages
						asynchronously.
					</li>
				</ul>
				Client (of enterprise bean) obtains a referenced instance of an enterprise bean by
				Dependency injection or JNDI lookup.
			</section>
			<section style="width: 800pt;right: -86.667px;left: -86.667px;">
				<h2>Enterprise Bean</h2>
				<table>
					<tr>
						<th>Type</th>
						<th>Features</th>
					</tr>
					<tr>
						<td>
							Stateful
						</td>
						<td style="padding-left: 0; padding-right: 0;">
							<ul style="margin-left: 0;">
								<li>maintains conversational state for a specific client</li>
								<li>can NOT implement a web service</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Stateless</td>
						<td style="padding-left: 0; padding-right: 0;">
							<ul style="margin-left: 0;">
								<li>does not maintain a conversational state with the client</li>
								<li>can implement a web service</li>
							</ul>
						</td>
					</tr>
					<tr>
						<td>Singleton</td>
						<td style="padding-left: 0; padding-right: 0;">
							<ul style="margin-left: 0;">
								<li>similar to stateless session beans, but:</li>
								<li>only one singleton session bean per app</li>
							</ul>
						</td>
					</tr>
				</table>
			</section>
			<section>
				<h2>Lifecycles of Enterprise Bean</h2>
			</section>
			<section>
				<h2>Lifecycle of Stateful Session Bean</h2>
				<img data-src="https://docs.oracle.com/javaee/7/tutorial/img/jeett_dt_021.png">
			</section>
			<section>
				<h2>Lifecycle of Stateless and Singleton Session Bean</h2>
				<img data-src="https://docs.oracle.com/javaee/7/tutorial/img/jeett_dt_022.png">
			</section>
		</section>
		<section>
			<section>
				<h1>Bean Validation</h1>
			</section>
			<section>
				<h2>Bean Validation</h2>
				<ul>
					<li>Validating input received from the user to maintain data integrity is an
						important part of application logic.
					</li>
					<li>Provides a facility for validating objects, object members, methods, and
						constructors.
					</li>
					<li>Allow developers to easily define and enforce validation constraints.</li>
				</ul>
			</section>
			<section>
				<h2>Bean Validation</h2>
				Built-in validators:<br>
				<iframe src="https://docs.oracle.com/javaee/7/tutorial/bean-validation001.htm#GKAGK"
						style="width: 700px; height: 500px;">
				</iframe>
			</section>
			<section>
				<h2>Bean Validation</h2>
				<p style="font-size: 22pt; text-align: left">Custom validation:</p>
				<p style="font-size: 18pt; text-align: left">
					Provided: Our project has entity id format: "{entity_type}_{uuid}",
					where "entity_type" in {"Setup", "SetupState", "Client", "ClientState",
					"ResourceServer", "ResourceServerState"}
					e.g: "Client_51AFCCB0179D498D89860BADEC10406F"
					Create a bean validation to validate an entity id.
				</p>
			</section>
		</section>
		<section>
			<section>
				<h1>Web Services with JAX-RS</h1>
			</section>
			<section>
				<h2>Web Services with JAX-RS</h2>
				helps developing REST architecture for Java EE applications.
				What do you need for a RESTful services:
				1. the base URI for all resource URIs specified by @Path annotations.
				2. a relative URI path indicating where the Java class will be hosted.
				3. Java method to process HTTP requests.
				4. extract parameters from HTTP request.
				5. specify the media types the client is allowed to send so that server resource can
				consume.
				6. specify the media types of representations a resource can produce and send back
				to the client.
			</section>
		</section>
		<section>
			<section>
				<h1>Packaging</h1>
			</section>
			<section>
				<h2>Packaging</h2>
				<ul>
					<li>A Java EE application is packaged into a Java Archive (JAR) file or a
						Web
						Archive (WAR) file or an Enterprise Archive (EAR) file for deployment.
					</li>
					<li>EJB-JAR: EJB modules, which contain class files for enterprise beans
						and,
						optionally,
						an EJB deployment descriptor.
					</li>
					<li>Application client modules, which contain class files and, optionally,
						an
						application client deployment descriptor. Application client modules are
						packaged as JAR files.
					</li>
					<li>Web modules, which contain servlet class files, web files, supporting
						class
						files, GIF and HTML files, and, optionally, a web application deployment
						descriptor. Web modules are packaged as WAR files.
					</li>
					<li>Resource adapter modules, which contain all Java interfaces, classes,
						native
						libraries, and, optionally, a resource adapter deployment descriptor.
						Together, these implement the Connector architecture for a particular
						EIS.
						Resource adapter modules are packaged as RAR files.
					</li>
					<li>The biggest difference between JAR, WAR and EAR files is the fact that
						they
						are targeted toward different environments. An EAR file requires a fully
						Java EE compliant application server (e.g. WebSphere, JBoss...) to run.
						A
						WAR
						file only requires a Java EE Web Profile-compliant application server to
						run, and a JAR file only requires a Java installation.
					</li>
					<li>A JAR file has all the components required to make a self-contained
						executable Java application, only requires a Java installation to
						execute.
					</li>
					<li>A WAR file contains the files of a web project. It can have servlet,
						JSP,
						XML, HTML, XHTML, CSS and JavaScript files, requires a Java EE Web
						Profile-compliant application server to run.
					</li>
					<li>EAR is a Java EE file that packages one or more modules into a single
						archive to deploy them onto an application server.
					</li>
					<li></li>
					<li></li>
				</ul>
			</section>
			<section>
				Structure of an Enterprise Bean JAR:
				<img data-src="https://docs.oracle.com/javaee/7/tutorial/img/jeett_dt_011.png">
			</section>
			<section>
				Structure of an Web Archive:
				<img data-src="https://docs.oracle.com/javaee/7/tutorial/img/jeett_dt_012.png">
			</section>
			<section>
				Structure of an Enterprise Application Archive:
				<img data-src="https://docs.oracle.com/javaee/7/tutorial/img/jeett_dt_010.png">
			</section>
		</section>
	</div>
</div>

<script src="js/reveal.js"></script>
<!--<script src="plugin/markdown/marked.js"></script>-->
<!--<script src="plugin/markdown/markdown.js"></script>-->

<script>
	Reveal.initialize({
		dependencies: [
			{src: 'plugin/markdown/marked.js'},
			{src: 'plugin/markdown/markdown.js'},
			{src: 'plugin/notes/notes.js', async: true},
			{src: 'plugin/highlight/highlight.js', async: true}
		]
	});
</script>
</body>

</html>
